package net.megx.was.webdav;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;

import javax.jcr.Repository;
import javax.servlet.ServletConfig;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;

import org.apache.jackrabbit.server.CredentialsProvider;
import org.apache.jackrabbit.webdav.simple.SimpleWebdavServlet;

public class SimpleWebdavServletImpl extends SimpleWebdavServlet {

    /**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	
	
	@Override
	public void init(ServletConfig config) throws ServletException {
		super.init(config);
		try {
			String resCfg = config.getInitParameter(SimpleWebdavServlet.INIT_PARAM_RESOURCE_CONFIG);
			URL re = getServletContext().getResource(resCfg);
			System.out.println(re);
		} catch (MalformedURLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	public SimpleWebdavServletImpl(Repository repository) {
		this.repository = repository;
	}

	/**
     * the jcr repository
     */
    private Repository repository;

    /**
     * Returns the <code>Repository</code>. If no repository has been set or
     * created the repository initialized by <code>RepositoryAccessServlet</code>
     * is returned.
     *
     * @return repository
     * @see RepositoryAccessServlet#getRepository(ServletContext)
     */
    public Repository getRepository() {
        return repository;
    }
    
    @Override
    protected CredentialsProvider getCredentialsProvider() {
    	return new DavCredentialsProvider(repository, getInitParameter(INIT_PARAM_MISSING_AUTH_MAPPING));
    }
    
    
    
    /*
     * (non-Javadoc)
     * @see org.apache.jackrabbit.webdav.server.AbstractWebdavServlet#service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)
     * 
     * This is a workaround for the HTTP errors generated by the Jackrabbit WebDAV servlet.
     * The issue occurs when there is an exception handling mechanism defined for the application in the deployment descriptor. When
     * an error occurs, the servlet will attempt to send an error to the client using HttpServletResponse.sendError() method. The
     * response is not immediately send to the client at this point, but the web container first checks for error handling for that
     * specific HTTP error code and/or Exception type.
     * The problem arises when such error (like 404) is checked for error handling and there is a mapping for it. If the error request is
     * forwarded to another servlet, there is a chance that the other servlet does not implement WebDAV Request methods (PROPFIND for example)
     * but implements only the standard HTTP methods (GET, POST, PUT, DELETE, HEAD, OPTIONS, TRACE) and (by default) responds with 501 "Not implemented"
     * when it receives an HTTP request with Method other than the above. Thus, the error received will be translated to 501 error, which is not 
     * really well received by the WebDAV clients.
     * The workaround is to make the WebDAV servlet flush the error to the user without going thru the standard error handling mechanism.
     * By Servlet specification, if the ServletResponse is already flushed to the client (isCommited), the server will not attempt to
     * forward the error request/response even if there is a error handling defined. Calling ServletResponse.flushBuffer() will flush
     * the response buffer to the client immediately and will commit the response. 
     */
    @Override
    protected void service(HttpServletRequest request,
    		HttpServletResponse response) throws ServletException, IOException {
    	super.service(request, new DAVServletResponse (response) );
    	if(!response.isCommitted())
    		response.flushBuffer();
    }
    
    public class DAVServletResponse extends HttpServletResponseWrapper{

		public DAVServletResponse(HttpServletResponse response) {
			super(response);
		}
    	
		@Override
		public void sendError(int sc) throws IOException {
			this.setStatus(sc);
			this.getWriter().print(sc);
			this.getWriter().flush();
			this.flushBuffer();
		}
		
		@Override
		public void sendError(int sc, String message) throws IOException {
			this.setStatus(sc);
			this.getWriter().print(message);
			this.getWriter().flush();
			this.flushBuffer();
		}
		
    }
    
}